#!/usr/bin/env python3
import argparse
import pickle
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import tqdm
import pyb_utils

import force_push as fp

import IPython


def compute_extreme_points(data):
    # compute the final point if the slider moved exactly along the path
    path = data["path"]
    dist = data["duration"] * data["push_speed"]
    ideal_final_pos = path.point_at_distance(dist)

    # compute distance between actual final points and the ideal one
    all_r_sw_ws = data["slider_positions"]
    num_sims = len(all_r_sw_ws)
    max_final_dist = (0, 0, [0, 0])  # index, distance, point
    for i in range(num_sims):
        final_slider_pos = all_r_sw_ws[i][-1, :2]
        final_dist = np.linalg.norm(ideal_final_pos - final_slider_pos)
        if final_dist > max_final_dist[1]:
            max_final_dist = (i, final_dist, final_slider_pos)

    # compute point of maximum deviation from the path (max closest distance)
    max_closest_point = (0, 0, [0, 0])  # index, distance, point
    with tqdm.tqdm(total=num_sims) as progress:
        for i in range(num_sims):
            for k in range(all_r_sw_ws[i].shape[0]):
                r_sw_w = all_r_sw_ws[i][k, :2]
                closest = path.compute_closest_point(r_sw_w)
                dist = np.linalg.norm(closest - r_sw_w)
                if dist > max_closest_point[1]:
                    max_closest_point = (i, dist, r_sw_w)
            progress.update(1)

    return {
        "ideal_final_pos": ideal_final_pos,
        "max_final_dist": max_final_dist,
        "max_closest_point": max_closest_point,
    }


def main():
    np.set_printoptions(precision=6, suppress=True)

    parser = argparse.ArgumentParser()
    parser.add_argument("file", help="npz file to load data from.")
    parser.add_argument("--save", action="store_true", help="Save the results.")
    args = parser.parse_args()

    input_path = Path(args.file)
    with open(input_path, "rb") as f:
        data = pickle.load(f)
    print(f"Loaded data from {args.file}")

    # check if we've already computed the needed results (i.e., the file has
    # been previously generated by this script)
    if "ideal_final_pos" not in data:
        results = compute_extreme_points(data)
        data.update(results)

    if args.save:
        output_path = Path(input_path.stem + "_results.pkl")
        with open(output_path, "wb") as f:
            pickle.dump(data, f)
        print(f"Saved processed data to {output_path}")

    fp.plot_simulation_results(data)

    max_final_dist = data["max_final_dist"]
    max_closest_point = data["max_closest_point"]
    print(f"Max final dist was {max_final_dist[1]} in run {max_final_dist[0]}")
    print(f"Max deviation was {max_closest_point[1]} in run {max_closest_point[0]}")
    plt.plot(
        [max_final_dist[2][0]],
        [max_final_dist[2][1]],
        "x",
        color="k",
        label="Max final dist",
    )
    plt.plot(
        [max_closest_point[2][0]],
        [max_closest_point[2][1]],
        "o",
        color="k",
        label="Max deviation",
    )
    plt.legend()

    plt.show()


if __name__ == "__main__":
    main()
