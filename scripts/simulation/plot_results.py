#!/usr/bin/env python3
import argparse
from collections import namedtuple
import pickle
from pathlib import Path

import matplotlib.pyplot as plt
import numpy as np
import tqdm
import pyb_utils

import force_push as fp

import IPython


ExtremePointInfo = namedtuple("ExtremePointInfo", ["index", "distance", "point"])


def compute_extreme_points(data):
    """Compute the extreme points of a set of runs.

    The extreme points are the finishing point that is farthest from the
    "ideal" end of the path (i.e., the distance a perfect system would achieve
    with the given speed) and the point of max distance from the path.
    """
    # compute the final point if the slider moved exactly along the path
    path = data["path"]
    dist = data["duration"] * data["push_speed"]
    ideal_final_pos = path.point_at_distance(dist)

    all_r_sw_ws = data["slider_positions"]
    num_sims = len(all_r_sw_ws)

    # compute distance between actual final points and the ideal one
    # we also compute the completion fraction for each run, which is the
    # fraction of the path completed by an ideal system if it ended the same
    # distance away from the end as the real system did
    max_final_info = ExtremePointInfo(index=0, distance=0, point=[0, 0])
    completion_fractions = []
    for i in range(num_sims):
        final_slider_pos = all_r_sw_ws[i][-1, :2]
        final_dist = np.linalg.norm(ideal_final_pos - final_slider_pos)
        completion_fractions.append((dist - final_dist) / dist)
        if final_dist > max_final_info.distance:
            max_final_info = ExtremePointInfo(i, final_dist, final_slider_pos)
    completion_fractions = np.array(completion_fractions)

    # compute point of maximum deviation from the path (max closest distance)
    max_deviation_info = ExtremePointInfo(index=0, distance=0, point=[0, 0])
    with tqdm.tqdm(total=num_sims) as progress:
        for i in range(num_sims):
            for k in range(all_r_sw_ws[i].shape[0]):
                r_sw_w = all_r_sw_ws[i][k, :2]
                closest = path.compute_closest_point(r_sw_w)
                dist = np.linalg.norm(closest - r_sw_w)
                if dist > max_deviation_info.distance:
                    max_deviation_info = ExtremePointInfo(i, dist, r_sw_w)
            progress.update(1)

    return {
        "ideal_final_pos": ideal_final_pos,
        "max_final_info": max_final_info,
        "max_deviation_info": max_deviation_info,
        "completion_fractions": completion_fractions,
    }


def main():
    np.set_printoptions(precision=6, suppress=True)

    parser = argparse.ArgumentParser()
    parser.add_argument("file", help="NPZ file to load data from.")
    parser.add_argument("--save", action="store_true", help="Save the results.")
    args = parser.parse_args()

    input_path = Path(args.file)
    with open(input_path, "rb") as f:
        data = pickle.load(f)
    print(f"Loaded data from {args.file}")

    # check if we've already computed the needed results (i.e., the file has
    # been previously generated by this script); if not, compute them
    if "ideal_final_pos" not in data:
        results = compute_extreme_points(data)
        data.update(results)

    if args.save:
        output_path = Path(input_path.stem + "_results.pkl")
        with open(output_path, "wb") as f:
            pickle.dump(data, f)
        print(f"Saved processed data to {output_path}")

    fp.plot_simulation_results(data)

    max_final_info = data["max_final_info"]
    max_deviation_info = data["max_deviation_info"]
    print(f"Max final dist was {max_final_info.distance} in run {max_final_info.index}")
    print(f"Max deviation was {max_deviation_info.distance} in run {max_deviation_info.index}")

    completion_fractions = data["completion_fractions"]
    mean_frac = np.mean(completion_fractions)
    std_frac = np.std(completion_fractions)
    print("\nCompletion")
    print(f"mean  = {mean_frac}")
    print(f"std   = {std_frac}")
    print(f"best  = {np.max(completion_fractions)}")
    print(f"worst = {np.min(completion_fractions)}")

    plt.plot(
        [max_final_info.point[0]],
        [max_final_info.point[1]],
        "x",
        color="k",
        label="Max final dist",
    )
    plt.plot(
        [max_deviation_info.point[0]],
        [max_deviation_info.point[1]],
        "o",
        color="k",
        label="Max deviation",
    )
    plt.legend()

    plt.show()


if __name__ == "__main__":
    main()
